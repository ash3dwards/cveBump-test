const _ = require("lodash");

/**
 * Normalises and deduplicates CVE records coming from multiple
 * upstream feeds (OSV, NVD, GitHub Advisories). Heavily relies
 * on lodash for deep merging, grouping, and safe property access.
 */

const SEVERITY_ORDER = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "UNKNOWN"];

/**
 * Given an array of raw advisory objects from mixed sources,
 * returns a deduplicated, merged, and severity-sorted array.
 */
function normaliseAdvisories(rawAdvisories) {
  // Group by canonical CVE ID, falling back to advisory-specific ID
  const grouped = _.groupBy(rawAdvisories, (adv) =>
    _.get(adv, "aliases[0]", adv.id || adv.cveId || "unknown")
  );

  const merged = _.map(grouped, (advisories, cveId) => {
    // Deep-merge all source records so no field is lost
    const base = _.mergeWith({}, ...advisories, (objVal, srcVal) => {
      if (_.isArray(objVal)) return _.uniq([...objVal, ...srcVal]);
    });

    // Pick the highest severity across sources
    const severities = _.compact(_.map(advisories, "severity"));
    const highestSeverity = _.minBy(severities, (s) =>
      SEVERITY_ORDER.indexOf(s.toUpperCase())
    );

    return {
      id: cveId,
      severity: highestSeverity || "UNKNOWN",
      sources: _.uniq(_.map(advisories, "source")),
      summary: _.get(base, "summary", ""),
      description: _.get(base, "description", _.get(base, "details", "")),
      aliases: _.uniq(_.compact(_.flatten(_.map(advisories, "aliases")))),
      affected: _.uniqBy(
        _.flatten(_.map(advisories, "affected")),
        (a) => `${_.get(a, "package.name")}@${_.get(a, "package.version")}`
      ),
      references: _.uniqBy(_.flatten(_.map(advisories, "references")), "url"),
      cvss: _.get(base, "cvss", {}),
      published: _.get(base, "published"),
      modified: _.get(base, "modified"),
    };
  });

  // Sort by severity â€” CRITICAL first
  return _.sortBy(merged, (item) =>
    SEVERITY_ORDER.indexOf((item.severity || "UNKNOWN").toUpperCase())
  );
}

/**
 * Computes a confidence score (0-1) based on source agreement.
 */
function computeConfidence(advisory) {
  const sourceCount = _.size(_.get(advisory, "sources", []));
  const hasCVSS = !_.isEmpty(_.get(advisory, "cvss"));
  const hasDescription = !_.isEmpty(_.get(advisory, "summary"));

  let score = 0;
  score += _.clamp(sourceCount / 3, 0, 0.5); // up to 0.5 for 3+ sources
  score += hasCVSS ? 0.3 : 0;
  score += hasDescription ? 0.2 : 0;

  return _.round(score, 2);
}

module.exports = { normaliseAdvisories, computeConfidence };
